<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>大老二-真實 (Fixed Edition)</title>
    <style>
        :root {
            --bg: #1b3d2f;
            --card-white: #ffffff;
            --accent: #f1c40f;
            --danger: #e74c3c;
        }
        body { font-family: 'PingFang TC', sans-serif; background: var(--bg); color: white; margin: 0; display: flex; flex-direction: column; align-items: center; height: 100vh; overflow: hidden; }
        
        #header { width: 100%; height: 100px; background: rgba(0,0,0,0.3); display: flex; justify-content: space-around; align-items: center; padding: 10px; }
        .opponent { text-align: center; padding: 5px 15px; border: 2px solid transparent; border-radius: 8px; transition: 0.3s; }
        .opponent.active { border-color: var(--accent); background: rgba(241, 196, 15, 0.1); }
        .card-back-icon { width: 25px; height: 35px; background: #2c3e50; border: 1px solid white; border-radius: 3px; margin: 5px auto; }

        #table-surface { flex-grow: 1; width: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; position: relative; }
        #last-played-zone { display: flex; gap: 10px; min-height: 120px; align-items: center; justify-content: center; width: 50%; border-radius: 20px; background: rgba(255,255,255,0.05); }
        
        .card { width: 65px; height: 90px; background: white; color: black; border-radius: 6px; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; border: 2px solid #ddd; box-shadow: 2px 2px 5px rgba(0,0,0,0.3); transition: 0.2s; position: relative; }
        .card.selected { transform: translateY(-15px); border-color: #3498db; box-shadow: 0 5px 15px rgba(52,152,219,0.5); }
        .card.red { color: var(--danger); }
        .card-rank { font-size: 1.5em; font-weight: bold; }
        .card-suit { font-size: 1.1em; position: absolute; top: 3px; left: 5px; }

        #player-hand-area { width: 100%; background: rgba(0,0,0,0.5); padding: 20px 0; display: flex; flex-direction: column; align-items: center; }
        #hand { display: flex; gap: 8px; justify-content: center; margin-bottom: 15px; flex-wrap: wrap; }
        
        .btn-group { display: flex; gap: 10px; height: 45px; }
        button { padding: 10px 20px; border-radius: 5px; border: none; font-weight: bold; cursor: pointer; background: #eee; }
        button:hover { background: var(--accent); }
        .btn-rule { background: #3498db; color: white; }
        
        #game-msg { position: absolute; top: 20%; background: var(--danger); padding: 10px 20px; border-radius: 5px; display: none; font-weight: bold; z-index: 10; }
        #info-banner { margin-bottom: 10px; font-size: 1.2em; color: var(--accent); text-shadow: 1px 1px 2px black; }
    </style>
</head>
<body>

<div id="header"></div>

<div id="table-surface">
    <div id="info-banner">點擊下方按鈕開始遊戲</div>
    <div id="last-played-zone"></div>
    <div id="game-msg"></div>
</div>

<div id="player-hand-area">
    <div id="hand"></div>
    
    <div id="rule-options" class="btn-group" style="display:none;">
        <span style="line-height:45px; margin-right:10px;">請決定本輪規則：</span>
        <button class="btn-rule" onclick="setRule('proximity')">數量鄰近 (接近真實)</button>
        <button class="btn-rule" onclick="setRule('suit')">花色一致 (且數字更大)</button>
    </div>

    <div id="action-btns" class="btn-group" style="display:none;">
        <button onclick="playHand()">出牌</button>
        <button onclick="passTurn()">Pass 跳過</button>
    </div>

    <button id="start-btn" onclick="setupGame()" style="padding:15px 40px; font-size:1.2em; background:var(--accent);">開始遊戲 (4人局)</button>
</div>

<script>
    const SUITS = ['♠', '♥', '♦', '♣'];
    const RANKS = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13];
    let players = [];
    let currentPlayerIdx = 0;
    let realityCard = null;
    let lastHand = null;
    let currentRule = null;
    let currentHandType = null;
    let passCount = 0;
    let gameActive = false;

    function setupGame() {
        const deck = [];
        SUITS.forEach(s => RANKS.forEach(r => deck.push({suit: s, rank: r})));
        deck.sort(() => Math.random() - 0.5);

        realityCard = deck.pop(); 
        console.log("真實牌是:", realityCard); // 偵錯用

        players = [];
        for(let i=0; i<4; i++) {
            players.push({
                id: i+1,
                hand: deck.splice(0, 12).sort((a,b) => a.rank - b.rank)
            });
        }

        gameActive = true;
        document.getElementById('start-btn').style.display = 'none';
        currentPlayerIdx = Math.floor(Math.random() * 4);
        
        updateUI();
        processTurn();
    }

    function processTurn() {
        if (!gameActive) return;

        // 如果所有人都 pass 剩一人，重置回合
        if (passCount >= players.length - 1 && lastHand !== null) {
            showMessage("一輪結束，新回合開始！");
            lastHand = null;
            currentRule = null;
            currentHandType = null;
            passCount = 0;
        }

        const isHuman = (currentPlayerIdx === 0);
        const p = players[currentPlayerIdx];

        // 顯示控制項
        if (isHuman) {
            if (!currentRule) {
                document.getElementById('rule-options').style.display = 'flex';
                document.getElementById('action-btns').style.display = 'none';
                document.getElementById('info-banner').innerText = "輪到你開局，請選擇本輪規則基準！";
            } else {
                document.getElementById('rule-options').style.display = 'none';
                document.getElementById('action-btns').style.display = 'flex';
                document.getElementById('info-banner').innerText = `輪到你，規則：${currentRule==='proximity'?'數量鄰近':'花色一致'}`;
            }
        } else {
            document.getElementById('rule-options').style.display = 'none';
            document.getElementById('action-btns').style.display = 'none';
            document.getElementById('info-banner').innerText = `玩家 ${p.id} 思考中...`;
            setTimeout(aiAutoPlay, 1500);
        }
        updateUI();
    }

    function setRule(rule) {
        currentRule = rule;
        showMessage(`已設定規則：${rule==='proximity'?'數量鄰近':'花色一致'}`);
        processTurn();
    }

    function updateUI() {
        // 更新對手
        const header = document.getElementById('header');
        header.innerHTML = '';
        players.forEach((p, idx) => {
            const div = document.createElement('div');
            div.className = `opponent ${idx === currentPlayerIdx ? 'active' : ''}`;
            div.innerHTML = `<div>玩家 ${p.id}</div><div class="card-back-icon"></div><div>${p.hand.length} 張</div>`;
            header.appendChild(div);
        });

        // 更新玩家手牌
        const handDiv = document.getElementById('hand');
        handDiv.innerHTML = '';
        players[0].hand.forEach((card, i) => {
            const cEl = document.createElement('div');
            cEl.className = `card ${['♥','♦'].includes(card.suit) ? 'red' : ''}`;
            cEl.innerHTML = `<span class="card-suit">${card.suit}</span><span class="card-rank">${card.rank}</span>`;
            cEl.onclick = () => cEl.classList.toggle('selected');
            cEl.dataset.idx = i;
            handDiv.appendChild(cEl);
        });
    }

    function playHand() {
        const selectedEls = document.querySelectorAll('.card.selected');
        const selectedCards = Array.from(selectedEls).map(el => players[0].hand[el.dataset.idx]);

        if (selectedCards.length === 0) return;

        // 檢查牌型 (簡化版：單張或對子)
        const type = selectedCards.length === 1 ? 'single' : (selectedCards.length === 2 && selectedCards[0].rank === selectedCards[1].rank ? 'pair' : null);
        
        if (!type || (currentHandType && type !== currentHandType)) {
            showMessage("不合法的牌型！");
            return;
        }

        // 規則驗證
        if (lastHand) {
            if (!checkReality(selectedCards)) {
                showMessage("不符合真實！請再試一次或 Pass");
                return;
            }
        }

        currentHandType = type;
        executeMove(selectedCards);
    }

    function checkReality(cards) {
        if (currentRule === 'proximity') {
            return Math.abs(cards[0].rank - realityCard.rank) < Math.abs(lastHand[0].rank - realityCard.rank);
        } else {
            const matchSuit = cards.some(c => c.suit === realityCard.suit);
            return matchSuit && cards[0].rank > lastHand[0].rank;
        }
    }

    function executeMove(cards) {
        const p = players[currentPlayerIdx];
        cards.forEach(c => {
            const idx = p.hand.findIndex(hc => hc.rank === c.rank && hc.suit === c.suit);
            p.hand.splice(idx, 1);
        });

        lastHand = cards;
        passCount = 0;
        
        // 渲染桌面
        const zone = document.getElementById('last-played-zone');
        zone.innerHTML = '';
        cards.forEach(c => {
            const cEl = document.createElement('div');
            cEl.className = `card ${['♥','♦'].includes(c.suit) ? 'red' : ''}`;
            cEl.innerHTML = `<span class="card-suit">${c.suit}</span><span class="card-rank">${c.rank}</span>`;
            zone.appendChild(cEl);
        });

        if (p.hand.length === 0) {
            alert(`玩家 ${p.id} 獲勝！真實是：${realityCard.suit}${realityCard.rank}`);
            location.reload();
            return;
        }

        currentPlayerIdx = (currentPlayerIdx + 1) % players.length;
        processTurn();
    }

    function passTurn() {
        passCount++;
        currentPlayerIdx = (currentPlayerIdx + 1) % players.length;
        processTurn();
    }

    function aiAutoPlay() {
        if (!currentRule) {
            setRule(Math.random() > 0.5 ? 'proximity' : 'suit');
            return;
        }
        // AI 邏輯：有 50% 機率直接 Pass 以簡化遊戲流程
        passTurn();
    }

    function showMessage(text) {
        const msg = document.getElementById('game-msg');
        msg.innerText = text;
        msg.style.display = 'block';
        setTimeout(() => msg.style.display = 'none', 1800);
    }
</script>

</body>
</html>
// ... (保留之前的 CSS 與 HTML 結構，替換 JavaScript 中的 getHandType 和相關邏輯)

function getHandType(cards) {
    const len = cards.length;
    // 將數字排序方便判斷
    const sortedRanks = cards.map(c => c.rank).sort((a, b) => a - b);
    
    // 統計各數字出現次數
    const counts = {};
    cards.forEach(c => counts[c.rank] = (counts[c.rank] || 0) + 1);
    const countVals = Object.values(counts);

    if (len === 1) return 'single';
    if (len === 2 && countVals.includes(2)) return 'pair';
    if (len === 3 && countVals.includes(3)) return 'triple';
    
    if (len === 5) {
        // 鐵支 (4+1)
        if (countVals.includes(4)) return 'fourkind';
        
        // 葫蘆 (3+2)
        if (countVals.includes(3) && countVals.includes(2)) return 'fullhouse';
        
        // 順子 (數字連續)
        let isStraight = true;
        for (let i = 0; i < 4; i++) {
            if (sortedRanks[i + 1] !== sortedRanks[i] + 1) {
                isStraight = false;
                break;
            }
        }
        if (isStraight) return 'straight';
    }
    
    return null; // 若不符合以上則回傳無效
}

// 獲取牌型中的「關鍵比較值」
function getKeyRank(cards, type) {
    const counts = {};
    cards.forEach(c => counts[c.rank] = (counts[c.rank] || 0) + 1);
    
    if (type === 'single' || type === 'pair' || type === 'triple') return cards[0].rank;
    if (type === 'straight') return Math.max(...cards.map(c => c.rank));
    if (type === 'fullhouse' || type === 'fourkind') {
        // 找出張數最多的那個數字 (葫蘆找3張的，鐵支找4張的)
        return parseInt(Object.keys(counts).find(key => counts[key] >= 3));
    }
    return cards[0].rank;
}

function checkReality(selectedCards) {
    const currentKey = getKeyRank(selectedCards, currentHandType);
    const lastKey = getKeyRank(lastHand, currentHandType);
    
    if (currentRule === 'proximity') {
        // 比誰更接近真實
        return Math.abs(currentKey - realityCard.rank) < Math.abs(lastKey - realityCard.rank);
    } else {
        // 花色一致：檢查出牌中是否包含真實花色，且數字更大
        const matchSuit = selectedCards.some(c => c.suit === realityCard.suit);
        return matchSuit && currentKey > lastKey;
    }
}
